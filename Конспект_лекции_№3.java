static
Используется для создания методов, не связанных с поведением класса
Для вызова static-метода можно без создания объекта
new Guy().createClone()
# Нам не нужен объект математики, чтобы совершать математические операции
Почему static у Main? Если бы не было static, то при вызове Main создавался бы объект Main (а он нам нафиг не нужен)
this и super
public class Human {
	boolean isMale;
	int age;
	String name;
	// Другие свойства
	public Human() {
		// Хотелось бы вызвать родительский конструктор
	}
	public void apply Skill(int age) {
		this.age = age;
	}
this нужно для того, чтобы 1) присвоить значение переменной доч. переменной значение переменной род. класса, если у них одинаковые имена
2) вызвать конструктов одного типа из другого
super - ключевое слово, дающее возможность обратиться к каким-то компонентам родительского класса (superкласс в джаве - родительский класс)
public class badBoy extends Human {
	public badBoy() {
		super("Name");
	}
}
Init blocks
public class A {
	public A() {
		System.out.println("whvbwwefe");
	}
	
	{
		System.out.println("vebtbkopvsd"); // Блок инициализации. Сначала выполняется он, потом конструкторы. Т.е.: 1) Блок род. класса; 2) Методы род. класса; 3) Блок доч. класса; 4) Методы доч. класса
	}
}
static блок инициализации нужен например для того, чтобы что-то посчитать и присвоить это статической переменной. Однако он вызывается только один раз, когда загружается файл. Преимущественно - бесполезен
Полиморфизм - "много форм чего-то очень похожего"
Переопределение методов (method overriding)
@Override - аннотация, дает указания компилятору для проверки идущего за ним методу
Перегрузка методов (method overloading)
Ковариантность (Covariance)
Абстрактные классы (и методы) - если мы что-то знаем про свойства объекта, но не до конца.
Создать abstract-класс невозможно. abstract нужен для того, чтобы этот класс наследовать. Недоопределенное поведение род. абстрактного класса доопределяется в доч. классах (обязательно)
Если абстрактный класс наследуется от абстрактного класса, то не обязательно доопределять методы (вроде как)
Энкапсуляция
Интерфейсы - похожи на наследование, только не extends, а implements. Отличие от абстрактных классов - возможность хранить объекты и взаимодействия с ними раздельно, а также "множественное наследование"
Интерфейсы и абстрактные классы будут раскрываться в третьей лабе
У любого класса в джаве есть метод getClass. Также все классы наследуются от Object
У Object тоже есть свои методы, например, toString (и лучше бы знать знать, что они делают по умолчанию)
enum - создание строгого количества некоторых объектов. Может реализовывать интерфейсы, но от него нельзя наследовать другие классы
Public enum signalTraffic {
	RED("красный"),
	YELLOW("жёлтый"),
	GREEN("зелёный")
}

public class Main {
	public static void main(String args[]) {
		signalTraffic red = signalTraffic.RED;
		System.out.println("Color of the signal - " + red.getName);
	}
}